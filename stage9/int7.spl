alias currentPID S0;
currentPID = (PTBR - 1024) / 8;

alias currentPCB S1;
currentPCB = READY_LIST + 32 * currentPID;

[READY_LIST + 32 * currentPID + 1] = 1; //Process in ready list


alias nextPID S4;
nextPID = (currentPID + 1) % 32;


//Searching for next process 
while([READY_LIST + 32 * nextPID + 1] != 1) do 
    nextPID = (nextPID + 1) % 32;
endwhile;


//If no Process Found 
if(nextPID == currentPID) then
    halt;
endif;


//Searching and closing files
alias pointer S2;
alias i S3;
i = 0;
while(i < 8) do
    pointer = [currentPCB + 15 + i * 2 + 0];
    if(pointer != -1) then 
        [FILE_TABLE + pointer * 2 + 1] = [FILE_TABLE + pointer * 2 + 1] - 1;
        if([FILE_TABLE + pointer * 2 + 1] == 0) then 
            [FILE_TABLE + pointer * 2 + 0] = -1;
        endif;
        [currentPCB + 15 + i * 2 + 0] = -1;
        [currentPCB + 15 + i * 2 + 1] = -1;
    endif;
    i = i + 1;
endwhile;

//Setting the state 
[currentPCB + 1] = 0;

//Freeing memory Pages and invalidating its Page table 
alias page S2;
i = 0;
while(i < PTLR) do
    page = [PTBR + i * 2 + 0];
    if(page != -1) then 
        [MEM_LIST + page] = 0;
    endif;
    [PTBR + i * 2 + 0] = -1;
    [PTBR + i * 2 + 1] = "00";
    i = i + 1;
endwhile;

//Schedule the next process
alias nextPCB S5;
nextPCB = READY_LIST + 32 * nextPID;

BP = [nextPCB + 2];
SP = [nextPCB + 3];
PTBR = [nextPCB + 5];
PTLR = [nextPCB + 6];
R0 = [nextPCB + 7];
R1 = [nextPCB + 8];
R2 = [nextPCB + 9];
R3 = [nextPCB + 10];
R4 = [nextPCB + 11];
R5 = [nextPCB + 12];
R6 = [nextPCB + 13];
R7 = [nextPCB + 14];

//Setting IP value
SP = SP + 1;
alias physicalSP S6;
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
[physicalSP] = [nextPCB + 4];
[nextPCB + 1] = 2;
ireturn;

[READY_LIST + 0] = 0;
[READY_LIST + 1] = 2; // running state
PTBR = 1024; 
[READY_LIST + 31] = 0 ; 
PTLR = 4; 
[PTBR + 0] = 25; 
[PTBR + 1] = "01";	
[PTBR + 2] = 26; 
[PTBR + 3] = "01";	
[PTBR + 4] = 27; 
[PTBR + 5] = "01";	
[PTBR + 6] = 28; 
[PTBR + 7] = "01"; 
SP = 3 * 512; 
[28 * 512] = 0;
load(7,1);//exhandler
load(8,2);
load(9,3);
load(10,4);	
load(11,5);
load(12,6);
load(13,7);// interrupt 2 rutine
load(14,8);
load(15,9);
load(16,10);
load(17,11);
load(18,12);
load(19,13);
load(20,14);
load(21,15);
load(22,16);
load(23,17);
load(24,18);
load (5, 19);// fat table
load (6, 20);// disk free list
load(25,21); 
load(26,22); 
load(27,23);







alias counter S0;			
counter = 0;
while ( counter <  128) do			
	[ FILE_TABLE + counter ] = -1;	
	[ FILE_TABLE + counter + 1] =  0; //SWOFT	
	counter = counter + 2;			
endwhile;

counter = 15;
while ( counter <= 30) do
	[READY_LIST + counter] =-1;   //PPOFT
	counter=counter+1;
endwhile;
counter = 0;
while ( counter<=28 ) do 	// used page in memory
	[1280 + counter ] =1;
	counter=counter+1;
endwhile;
while ( counter<64) do 
	[1280 + counter ] =0 ;// unused page in memory
	counter=counter+1;
endwhile;
counter = 1;
while( counter<32) do
	[1536 + counter *32 + 1] =0; //state of all pcb's is 0 means terminated
	counter= counter+1;
endwhile;
//alias newptbr S1;
//newptbr = 1024 + 8 * 1;
//load(29,25);
//[READY_LIST + 32 + 0] = 1;
//[READY_LIST + 32 + 1] = 1; 
//[READY_LIST + 32 + 2] = 3 * 512;
//[READY_LIST + 32 + 3] = 3 * 512;
//[READY_LIST + 32 + 4] = 0;
//[READY_LIST + 32 + 5] = newptbr;
//[READY_LIST + 32 + 6] = 4;


//[newptbr + 0 ] = 29;
//[newptbr + 1] = "01";
//[newptbr + 2] = -1;
//[newptbr + 3] = "00";
//[newptbr + 4] = -1;
//[newptbr + 5] = "00";
//[newptbr + 6] = 30;
//[newptbr + 7] = "01";

//[1280 + 29]=1;// used
//[1280 + 30]=1;



ireturn;
